rag-backup-assistant/
â”œâ”€â”€ data/                  # Fichiers Ã  indexer (tu les ajoutes ici)
â”‚   â”œâ”€â”€ logs/
â”‚   â”œâ”€â”€ images/
â”‚   â””â”€â”€ policies/
â”œâ”€â”€ db/                    # Persisted Chroma DB
â”œâ”€â”€ ingest.py
â”œâ”€â”€ chat.py
â”œâ”€â”€ config.yaml            # Pour options futures (langue, modÃ¨le, etc.)
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md


curl -fsSL https://ollama.com/install.sh | sh
ollama pull mistral


ðŸ§ª Ã‰tapes d'exÃ©cution
Installe les dÃ©pendances :
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt

Lance lâ€™indexation :
python ingest.py

Ouvre le chat :
python chat.py


Chroma require sqlite, use faiss-cpu
pip install faiss-cpu


LLAMA CPP : 

pip install llama-cpp-python

âœ… 2. Adaptation dans chat.py

Remplace :

from llm_wrapper import CTransformersLLM
...
llm = CTransformersLLM(...)
par :

from llm_wrapper_cpp import LlamaCppLLM
...
llm = LlamaCppLLM(
    model_path="models/mistral-7b-instruct-v0.1.Q4_K_M.gguf",
    n_ctx=2048,
    n_threads=4,
    n_batch=8,
    temperature=0.1,
    max_tokens=512,
)




from datetime import timedelta

DAYS = {1: "Sunday", 2: "Monday", 3: "Tuesday", 4: "Wednesday",
        5: "Thursday", 6: "Friday", 7: "Saturday"}

WEEKS = {1: "first week", 2: "second week", 3: "third week",
         4: "fourth week", 5: "fifth week", 6: "every week"}


def seconds_to_hhmm(seconds):
    """Convert seconds since midnight to HH:MM"""
    t = timedelta(seconds=seconds)
    h, remainder = divmod(t.seconds, 3600)
    m, _ = divmod(remainder, 60)
    return f"{h:02}:{m:02}"


def parse_start_window(start_windows):
    windows = []
    human = []
    for w in start_windows:
        day = DAYS.get(w["dayOfWeek"], f"Day{w['dayOfWeek']}")
        start = seconds_to_hhmm(w["startSeconds"])
        end_seconds = w["startSeconds"] + w["durationSeconds"]
        end = seconds_to_hhmm(end_seconds % 86400)
        windows.append({"day": day, "start": start, "end": end})
        human.append(f"{day} {start}-{end}")
    return windows, human


def parse_recurring_days_of_week(days_list):
    """Parse list like ['2:3', '3:4'] -> readable"""
    result = []
    for d in days_list:
        day, week = map(int, d.split(":"))
        day_name = DAYS.get(day, f"Day{day}")
        week_name = WEEKS.get(week, f"week {week}")
        result.append({"day": day_name, "week": week_name})
    return result


def simplify_schedule(schedule_item):
    output = {
        "scheduleName": schedule_item.get("scheduleName"),
        "backupType": schedule_item.get("backupType"),
        "include": {},
        "exclude": {},
        "startWindow": [],
        "human_text": ""
    }

    human_parts = []

    # --- IncludeDates ---
    include = schedule_item.get("includeDates", {})
    inc = {}
    if include.get("lastDayOfMonth"):
        inc["lastDayOfMonth"] = True
        human_parts.append("Include: last day of month")
    if include.get("recurringDaysOfWeek"):
        inc["recurringDaysOfWeek"] = parse_recurring_days_of_week(include["recurringDaysOfWeek"])
        human_parts.append(
            "Include: recurring days of week " +
            ", ".join([f"{x['day']} ({x['week']})" for x in inc["recurringDaysOfWeek"]])
        )
    if include.get("recurringDaysOfMonth"):
        inc["recurringDaysOfMonth"] = include["recurringDaysOfMonth"]
        human_parts.append(f"Include: recurring days of month {inc['recurringDaysOfMonth']}")
    if include.get("specificDates"):
        inc["specificDates"] = include["specificDates"]
        human_parts.append(f"Include: specific dates {', '.join(inc['specificDates'])}")
    output["include"] = inc

    # --- ExcludeDates ---
    exclude = schedule_item.get("excludeDates", {})
    exc = {}
    if exclude.get("lastDayOfMonth"):
        exc["lastDayOfMonth"] = True
        human_parts.append("Exclude: last day of month")
    if exclude.get("recurringDaysOfWeek"):
        exc["recurringDaysOfWeek"] = parse_recurring_days_of_week(exclude["recurringDaysOfWeek"])
        human_parts.append(
            "Exclude: recurring days of week " +
            ", ".join([f"{x['day']} ({x['week']})" for x in exc["recurringDaysOfWeek"]])
        )
    if exclude.get("recurringDaysOfMonth"):
        exc["recurringDaysOfMonth"] = exclude["recurringDaysOfMonth"]
        human_parts.append(f"Exclude: recurring days of month {exc['recurringDaysOfMonth']}")
    if exclude.get("specificDates"):
        exc["specificDates"] = exclude["specificDates"]
        human_parts.append(f"Exclude: specific dates {', '.join(exc['specificDates'])}")
    output["exclude"] = exc

    # --- StartWindow ---
    if "startWindow" in schedule_item:
        windows, human_windows = parse_start_window(schedule_item["startWindow"])
        output["startWindow"] = windows
        human_parts.append("Start windows: " + ", ".join(human_windows))

    # --- Human text ---
    output["human_text"] = " | ".join(human_parts)

    return output


def parse_schedules(schedule_json):
    schedules = schedule_json.get("schedules", [])
    return [simplify_schedule(item) for item in schedules]


# ==== Example usage ====
schedule_json = {
    "schedules": [
        {
            "scheduleName": "TestSchedule",
            "backupType": "Full Backup",
            "includeDates": {
                "lastDayOfMonth": True,
                "recurringDaysOfWeek": ["2:3", "3:4"],
                "recurringDaysOfMonth": [10, 13],
                "specificDates": ["2018-12-31"]
            },
            "excludeDates": {
                "lastDayOfMonth": True,
                "recurringDaysOfWeek": ["4:6", "2:5"],
                "recurringDaysOfMonth": [10],
                "specificDates": ["2018-1-1", "2018-2-30"]
            },
            "startWindow": [
                {"dayOfWeek": 1, "startSeconds": 14600, "durationSeconds": 24600},
                {"dayOfWeek": 2, "startSeconds": 14600, "durationSeconds": 24600}
            ]
        }
    ]
}

import json
print(json.dumps(parse_schedules(schedule_json), indent=2))

