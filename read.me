rag-backup-assistant/
â”œâ”€â”€ data/                  # Fichiers Ã  indexer (tu les ajoutes ici)
â”‚   â”œâ”€â”€ logs/
â”‚   â”œâ”€â”€ images/
â”‚   â””â”€â”€ policies/
â”œâ”€â”€ db/                    # Persisted Chroma DB
â”œâ”€â”€ ingest.py
â”œâ”€â”€ chat.py
â”œâ”€â”€ config.yaml            # Pour options futures (langue, modÃ¨le, etc.)
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md


curl -fsSL https://ollama.com/install.sh | sh
ollama pull mistral


ðŸ§ª Ã‰tapes d'exÃ©cution
Installe les dÃ©pendances :
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt

Lance lâ€™indexation :
python ingest.py

Ouvre le chat :
python chat.py


Chroma require sqlite, use faiss-cpu
pip install faiss-cpu


LLAMA CPP : 

pip install llama-cpp-python

âœ… 2. Adaptation dans chat.py

Remplace :

from llm_wrapper import CTransformersLLM
...
llm = CTransformersLLM(...)
par :

from llm_wrapper_cpp import LlamaCppLLM
...
llm = LlamaCppLLM(
    model_path="models/mistral-7b-instruct-v0.1.Q4_K_M.gguf",
    n_ctx=2048,
    n_threads=4,
    n_batch=8,
    temperature=0.1,
    max_tokens=512,
)





import json

# Mapping utile des jours (selon NetBackup, 1 = Monday... 7 = Sunday)
DAYS_MAP = {
    1: "Monday", 2: "Tuesday", 3: "Wednesday",
    4: "Thursday", 5: "Friday", 6: "Saturday", 7: "Sunday"
}

def parse_recurring_days(recs, is_week=True):
    """Convert '1:6' to 'Monday at 6h' if is_week, else just 'Day X'."""
    parsed = []
    for r in recs:
        if is_week and ':' in r:
            day, hour = r.split(':')
            parsed.append(f"{DAYS_MAP.get(int(day), 'Day '+day)} at {hour}h")
        else:
            parsed.append(r)
    return parsed

def simplify_schedules(schedules):
    simplified = []
    summaries = []

    for sched in schedules:
        name = sched.get("scheduleName", "<unnamed>")
        btype = sched.get("backupType", "Unknown")
        freq_days = sched.get("frequencySeconds", 0) // 86400 if sched.get("frequencySeconds") else None

        # Retention & Storage
        copies = sched.get("backupCopies", {}).get("copies", [])
        if copies:
            cp = copies[0]
            retention = f"{cp['retentionPeriod']['value']} {cp['retentionPeriod']['unit']}"
            storage = cp.get("storage", "Unknown")
        else:
            retention = storage = None

        # Windows
        windows = []
        for w in sched.get("startWindow", []):
            dur_h = w["durationSeconds"] // 3600
            if dur_h > 0:
                windows.append({
                    "dayName": DAYS_MAP.get(w["dayOfWeek"], f"Day {w['dayOfWeek']}"),
                    "startHour": w["startSeconds"] // 3600,
                    "durationHours": dur_h
                })

        # Include Dates (recurring week/month)
        inc = sched.get("includeDates", {})
        inc_days = parse_recurring_days(inc.get("recurringDaysOfWeek", []), is_week=True)
        inc_month = parse_recurring_days(inc.get("recurringDaysOfMonth", []), is_week=False)
        inc_spec = inc.get("specificDates", [])
        includes = inc_days + inc_month + inc_spec

        # Exclude Dates
        excl = sched.get("excludeDates", {})
        excludes = []
        if excl.get("lastDayOfMonth"):
            excludes.append("Last day of month")
        excludes += parse_recurring_days(excl.get("recurringDaysOfWeek", []), is_week=True)
        excludes += parse_recurring_days(excl.get("recurringDaysOfMonth", []), is_week=False)
        excludes += excl.get("specificDates", [])

        simplified.append({
            "name": name,
            "type": btype,
            "frequency_days": freq_days,
            "retention": retention,
            "storage": storage,
            "windows": windows,
            "includes": includes,
            "excludes": excludes,
            "acceleratorForcedRescan": sched.get("acceleratorForcedRescan", False),
            "mediaMultiplexing": sched.get("mediaMultiplexing"),
            "retriesAllowedAfterRunDay": sched.get("retriesAllowedAfterRunDay"),
            "syntheticBackup": sched.get("syntheticBackup"),
        })

        # Build summary
        win_desc = "; ".join(f"{w['dayName']} at {w['startHour']}h for {w['durationHours']}h"
                             for w in windows) or "no active window"
        inc_desc = f" Includes: {', '.join(includes)}." if includes else ""
        excl_desc = f" Excludes: {', '.join(excludes)}." if excludes else ""
        acc_desc = " with accelerator forced rescan" if sched.get("acceleratorForcedRescan") else ""
        retry_desc = " retries allowed on next day." if sched.get("retriesAllowedAfterRunDay") else ""
        synth_desc = " (synthetic)" if sched.get("syntheticBackup") else ""
        mux_desc = f" Multiplexing: {sched.get('mediaMultiplexing')}." if sched.get("mediaMultiplexing") else ""

        summary = (
            f"Schedule '{name}' is a {btype.lower()}{synth_desc} every {freq_days} days, "
            f"stored on {storage} with retention {retention}{acc_desc}.{mux_desc}"
            f" Runs: {win_desc}.{inc_desc}{excl_desc}{retry_desc}"
        )
        summaries.append(summary)

    return {"simplified": simplified, "summaries": summaries}


# Usage example
schedules = [ ... ]  # ton input ici
result = simplify_schedules(schedules)
print(json.dumps(result, indent=2))



import json
print(json.dumps(simplify_schedules(schedule_json), indent=2))
