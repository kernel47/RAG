rag-backup-assistant/
â”œâ”€â”€ data/                  # Fichiers Ã  indexer (tu les ajoutes ici)
â”‚   â”œâ”€â”€ logs/
â”‚   â”œâ”€â”€ images/
â”‚   â””â”€â”€ policies/
â”œâ”€â”€ db/                    # Persisted Chroma DB
â”œâ”€â”€ ingest.py
â”œâ”€â”€ chat.py
â”œâ”€â”€ config.yaml            # Pour options futures (langue, modÃ¨le, etc.)
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md


curl -fsSL https://ollama.com/install.sh | sh
ollama pull mistral


ðŸ§ª Ã‰tapes d'exÃ©cution
Installe les dÃ©pendances :
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt

Lance lâ€™indexation :
python ingest.py

Ouvre le chat :
python chat.py


Chroma require sqlite, use faiss-cpu
pip install faiss-cpu


LLAMA CPP : 

pip install llama-cpp-python

âœ… 2. Adaptation dans chat.py

Remplace :

from llm_wrapper import CTransformersLLM
...
llm = CTransformersLLM(...)
par :

from llm_wrapper_cpp import LlamaCppLLM
...
llm = LlamaCppLLM(
    model_path="models/mistral-7b-instruct-v0.1.Q4_K_M.gguf",
    n_ctx=2048,
    n_threads=4,
    n_batch=8,
    temperature=0.1,
    max_tokens=512,
)




from datetime import timedelta

DAYS = {1: "Sunday", 2: "Monday", 3: "Tuesday", 4: "Wednesday",
        5: "Thursday", 6: "Friday", 7: "Saturday"}

WEEKS = {1: "first week", 2: "second week", 3: "third week",
         4: "fourth week", 5: "fifth week", 6: "every week"}


def seconds_to_hhmm(seconds):
    """Convert seconds since midnight to HH:MM"""
    t = timedelta(seconds=seconds)
    h, remainder = divmod(t.seconds, 3600)
    m, _ = divmod(remainder, 60)
    return f"{h:02}:{m:02}"


def parse_start_window(start_windows):
    windows = []
    human = []
    for w in start_windows:
        day = DAYS.get(w["dayOfWeek"], f"Day{w['dayOfWeek']}")
        start = seconds_to_hhmm(w["startSeconds"])
        end_seconds = w["startSeconds"] + w["durationSeconds"]
        end = seconds_to_hhmm(end_seconds % 86400)
        windows.append({"day": day, "start": start, "end": end})
        human.append(f"{day} {start}-{end}")
    return windows, human


def parse_recurring_days_of_week(days_list):
    """Parse list like ['2:3', '3:4'] -> readable"""
    result = []
    for d in days_list:
        day, week = map(int, d.split(":"))
        day_name = DAYS.get(day, f"Day{day}")
        week_name = WEEKS.get(week, f"week {week}")
        result.append({"day": day_name, "week": week_name})
    return result


def simplify_schedule(schedule_item):
    output = {
        "scheduleName": schedule_item.get("scheduleName"),
        "backupType": schedule_item.get("backupType"),
        "include": {},
        "exclude": {},
        "startWindow": [],
        "human_text": ""
    }

    human_parts = []

    # --- IncludeDates ---
    include = schedule_item.get("includeDates", {})
    inc = {}
    if include.get("lastDayOfMonth"):
        inc["lastDayOfMonth"] = True
        human_parts.append("Include: last day of month")
    if include.get("recurringDaysOfWeek"):
        inc["recurringDaysOfWeek"] = parse_recurring_days_of_week(include["recurringDaysOfWeek"])
        human_parts.append(
            "Include: recurring days of week " +
            ", ".join([f"{x['day']} ({x['week']})" for x in inc["recurringDaysOfWeek"]])
        )
    if include.get("recurringDaysOfMonth"):
        inc["recurringDaysOfMonth"] = include["recurringDaysOfMonth"]
        human_parts.append(f"Include: recurring days of month {inc['recurringDaysOfMonth']}")
    if include.get("specificDates"):
        inc["specificDates"] = include["specificDates"]
        human_parts.append(f"Include: specific dates {', '.join(inc['specificDates'])}")
    output["include"] = inc

    # --- ExcludeDates ---
    exclude = schedule_item.get("excludeDates", {})
    exc = {}
    if exclude.get("lastDayOfMonth"):
        exc["lastDayOfMonth"] = True
        human_parts.append("Exclude: last day of month")
    if exclude.get("recurringDaysOfWeek"):
        exc["recurringDaysOfWeek"] = parse_recurring_days_of_week(exclude["recurringDaysOfWeek"])
        human_parts.append(
            "Exclude: recurring days of week " +
            ", ".join([f"{x['day']} ({x['week']})" for x in exc["recurringDaysOfWeek"]])
        )
    if exclude.get("recurringDaysOfMonth"):
        exc["recurringDaysOfMonth"] = exclude["recurringDaysOfMonth"]
        human_parts.append(f"Exclude: recurring days of month {exc['recurringDaysOfMonth']}")
    if exclude.get("specificDates"):
        exc["specificDates"] = exclude["specificDates"]
        human_parts.append(f"Exclude: specific dates {', '.join(exc['specificDates'])}")
    output["exclude"] = exc

    # --- StartWindow ---
    if "startWindow" in schedule_item:
        windows, human_windows = parse_start_window(schedule_item["startWindow"])
        output["startWindow"] = windows
        human_parts.append("Start windows: " + ", ".join(human_windows))

    # --- Human text ---
    output["human_text"] = " | ".join(human_parts)

    return output


def parse_schedules(schedule_json):
    schedules = schedule_json.get("schedules", [])
    return [simplify_schedule(item) for item in schedules]


# ==== Example usage ====
schedule_json = {
    "schedules": [
        {
            "scheduleName": "TestSchedule",
            "backupType": "Full Backup",
            "includeDates": {
                "lastDayOfMonth": True,
                "recurringDaysOfWeek": ["2:3", "3:4"],
                "recurringDaysOfMonth": [10, 13],
                "specificDates": ["2018-12-31"]
            },
            "excludeDates": {
                "lastDayOfMonth": True,
                "recurringDaysOfWeek": ["4:6", "2:5"],
                "recurringDaysOfMonth": [10],
                "specificDates": ["2018-1-1", "2018-2-30"]
            },
            "startWindow": [
                {"dayOfWeek": 1, "startSeconds": 14600, "durationSeconds": 24600},
                {"dayOfWeek": 2, "startSeconds": 14600, "durationSeconds": 24600}
            ]
        }
    ]
}

import json
print(json.dumps(parse_schedules(schedule_json), indent=2))

-------------------------------------------------------------------------------------------




from datetime import timedelta
from collections import defaultdict

DAYS = {1: "Sun", 2: "Mon", 3: "Tue", 4: "Wed", 5: "Thu", 6: "Fri", 7: "Sat"}

def seconds_to_hhmm(sec):
    h, m = divmod(sec // 60, 60)
    return f"{h:02}:{m:02}"

def build_weeks_from_startwindows(start_windows):
    """Return dict week -> day -> list of start/end times (default week='every week')"""
    weeks = defaultdict(lambda: defaultdict(list))
    for w in start_windows:
        day = DAYS.get(w["dayOfWeek"], f"Day{w['dayOfWeek']}")
        start = seconds_to_hhmm(w["startSeconds"])
        end = seconds_to_hhmm(w["startSeconds"] + w["durationSeconds"])
        weeks["every week"][day].append({"startTime": start, "endTime": end})
    return dict(weeks)

def build_weeks_from_recurring(rec_list):
    """Parse recurringDaysOfWeek like ['2:3'] -> week -> day -> empty list"""
    weeks = defaultdict(lambda: defaultdict(list))
    for d in rec_list:
        day_num, week_num = map(int, d.split(":"))
        day = DAYS.get(day_num, f"Day{day_num}")
        week = f"week {week_num}" if week_num != 6 else "every week"
        weeks[week][day]  # initialize empty list
    return dict(weeks)

def merge_include_exclude(include, exclude):
    """Return merged dict after removing excluded days"""
    total = {}
    for week, days in include.items():
        total[week] = {}
        for day, times in days.items():
            if week in exclude and day in exclude[week]:
                continue
            total[week][day] = times
    return total

def simplify_schedule_item(schedule):
    # Include
    include = build_weeks_from_startwindows(schedule.get("startWindow", []))
    include_rec = build_weeks_from_recurring(schedule.get("includeDates", {}).get("recurringDaysOfWeek", []))
    # merge recurring empty entries with actual start windows
    for w, days in include_rec.items():
        include.setdefault(w, {}).update(days)

    # Exclude
    exclude = build_weeks_from_recurring(schedule.get("excludeDates", {}).get("recurringDaysOfWeek", []))

    # Total
    total = merge_include_exclude(include, exclude)

    # Human-readable resume
    human_parts = []
    for w, days in include.items():
        for d, times in days.items():
            if times:
                human_parts.append(f"Include {w} {d}: " + ", ".join([f"{t['startTime']}-{t['endTime']}" for t in times]))
            else:
                human_parts.append(f"Include {w} {d}")
    for w, days in exclude.items():
        for d in days.keys():
            human_parts.append(f"Exclude {w} {d}")

    return {
        "scheduleName": schedule.get("scheduleName"),
        "include": include,
        "exclude": exclude,
        "total": total,
        "resume": " | ".join(human_parts)
    }

def simplify_schedules(schedule_json):
    return [simplify_schedule_item(s) for s in schedule_json.get("schedules", [])]

# ==== Example ====
schedule_json = {
    "schedules": [
        {
            "scheduleName": "TestSchedule",
            "startWindow": [
                {"dayOfWeek": 1, "startSeconds": 14600, "durationSeconds": 24600},
                {"dayOfWeek": 2, "startSeconds": 14600, "durationSeconds": 24600}
            ],
            "includeDates": {"recurringDaysOfWeek": ["2:3", "3:4"]},
            "excludeDates": {"recurringDaysOfWeek": ["4:6", "2:5"]}
        }
    ]
}

import json
print(json.dumps(simplify_schedules(schedule_json), indent=2))
